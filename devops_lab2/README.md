# Лабораторная работа №2

## Установка Docker
Скачиваем Docker с официального сайта https://app.docker.com/ . В моем случае надо было скачать версию для Windows.
Перезагружаем компьютер. Регистрируемся на сайте и логинимся в десктопной версии. Автоматически у нас появится и логин на Dockerhub https://hub.docker.com/ (платформа типа гитхаба, где можно найти большое кол-во опенсурсных образов и использовать их как основу при написании своих докерфайлов)

## Cоздаем тестовый сайт
1. В VS Code cоздаем новую папку `devOpsLab2` под наш проект, в ней файлик `index.html`
   
   ![image](https://github.com/user-attachments/assets/34080d8f-f825-4dc9-bc0e-44972fc60af2)
   
2. В `index.html` вводим простенький код, который выводит фразу "Проверка работы"
```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
     <meta charset="UTF-8">
     <meta http-equiv="X-UA-Compatible" content="IE=edge">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>Document</title>
   </head>
   <body>
   <h1>Проверка работы</h1>
   </body>
   </html>
```

## Написание Dockerfile`ов
Dockerfile - это инструкция,которая говорит докеру, как ему собрать конкретный образ для нашего конкретного проекта. В этой инструкции мы должны указать, какая ОС должна быть в нашем образе (причем нам нужна облегченная версия, со всем минимально необходимым для работы нашего проекта), какие дополнительные библиотеки нам нужны, чтобы проект работал (например, JDK для приложения на java), и с помощью какой команды контейнер будет запускать наше приложение.

Чтобы написать Dockerfile, в папке `devOpsLab2` создадим файл `Dockerfile`. Важно, чтобы название файла было именно таким.

![image](https://github.com/user-attachments/assets/26f0e613-ce8a-4276-af3c-9811c8e1ae91)

Сначала напишем плохой Dockerfile:
```
# загружаем лёгкий образ Nginx 
FROM nginx:1.27.2-alpine-slim

# устанавливаем рабочую директорию в корневом каталоге
WORKDIR /

# открываем порт 80 и 443 (не нужный для данной конфигурации)
EXPOSE 80
EXPOSE 443

# копируем все файлы в текущую директорию Nginx (вместо нужных файлов)
COPY . /usr/share/nginx/html/

# запускаем Nginx
CMD ["nginx", "-g", "daemon off;"]
```


Теперь подправим код и получим хороший Dockerfile:

```
# загружаем лёгкий образ Nginx 
FROM nginx:1.27.2-alpine-slim

# устанавливаем рабочую директорию
WORKDIR /usr/src/app/

# открываем порт 80
EXPOSE 80

# копируем только нужные файлы сайта (загружаем их в директорию Nginx)
COPY index.html /usr/share/nginx/html/

# запускаем Nginx
CMD ["nginx", "-g", "daemon off;"]
```

* Хотя в моем примере хостовая ОС Windows, а гостевая ОС (ОС контейнера) Linux, проблем все равно не возникнет, потому что Docker автоматически запускает контейнер в виртуальной Linux-среде (через WSL2)
  
результат для плохого докерфайла:

![image](https://github.com/user-attachments/assets/5dc69936-b99a-419b-9bc2-1c16f2fd5f33)

результат для хорошего докерфайла:

![image](https://github.com/user-attachments/assets/44616966-9a5c-44af-86a7-5968861132b2)


## За кадром: как построили образ, запустили контейнеры и проверили работу проекта

1. В VS code открываем консолль и с помощью команды `cd` переходим в папку `devOpsLab2`, в которой расположен наш Dockerfile
2. Используем следующую команду, чтобы построить образ:
   ```
   docker build -t devopslab2 .
   ```
с помощью `-t` мы присваиваем имя `devopslab2` нашему образу, а `.` указывает на то, что докер должен искать Dockerfile именно в том каталоге, в котором мы сейчас находимся

3. Переходим в десктопную версию докера. Теперь в разделе `Images` появился наш образ:

<img src="https://github.com/user-attachments/assets/5c947096-addf-4b36-8f25-267b8396c2f6" width="70%" height="70%" />

4. Нажимаем на кнопку `Run`, чтобы запустить контейнер. В дополнительных параметрах указываем имя контейнера (в нашем случае container_from_good_dockerfile) и указываем порт 80. Вообще имя можно придумать любое, а если оставить пустым, то оно сгенерируется рандомно. В конце нажимаем на кнопку `Run`

   <img src="https://github.com/user-attachments/assets/7037b11d-6cdf-4d8b-9e46-9b11302ed5cd" width="50%" height="50%" />

аналогичные действия были сделаны с плохим докерфайлом:

   <img src="https://github.com/user-attachments/assets/2487e239-d8f6-4a3c-9f53-45f42fd7c8ac" width="50%" height="50%" />

5. Далее переходим в браузер и вбиваем localhost


## Сравнение Dockerfile`ов

Опишем плохие практики, исполтзованные в пллохом докерфайле

1. Рабочую директория установлена в корневую папку `WORKDIR /`
    Это усложнит работу с консолью, когда нужно будет указывать относительные пути. Фактически все пути придется указывать как абсолютные
2. Открытие лишнего порта `EXPOSE 443`
    Ненужное действие, т.к. в данном проекте этот порт не используется
3. Копирование всех файлов из текущей директории(в нашем случае папка devOpsLab2) в каталог Nginx
   Если текущая директория содержит большое количество объемный файлов, то неоправданно уввеличим размер образа. Также это действие относительно небезопасно, т.к. может привести к утчечки конфиденциальных данных, которые располагаются в текущей директории

Исправления:
1. Корректно устанавим рабочую директорию `WORKDIR /usr/src/app/`
2. Откроем только нужный порт `EXPOSE 80`
3. Скопируем только нужные файлы `COPY index.html /usr/share/nginx/html/`

При таком подходете работа с контейнерами станет удобнее и вероятность допустить ошибку при работе с каталогами уменьшится. Но, конечно, указанные плохие практики все-равно остаются работоспособными в рамках нашего простого тестового проекта, т.к. полученные результаты при запросе в браузере одинаковы для обоих контейнеров.

## Описание двух плохих практики по работе с контейнерами

1. Игнорирование квот на память и ресурсы процессора, установленные для данного приложения. В Docker можно установить ограничения на ресурсы, потребляемые данным контейнером. Пренебрежение этими ограничениями и отсутствие мониторинга может привести к аварийному завершению работы приложения.
2. Запуск контейнеров с правами root. Это может привести к проблемам с безопасностью.
